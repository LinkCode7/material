# C++编译效率

## C/C++代码构建过程
- 预处理
在此阶段主要完成的工作是将头文件展开、替换宏指令、条件编译展开、消除注释。
- 编译
在此阶段主要将预编译好的文件转换成汇编语言（高级语言->LLVM平台无关语言->平台汇编语言）。
- 汇编
在此阶段将汇编语言转换为二进制机器语言。
- 链接
将编译产物和预编译制品（.o、.a、.so）“拼”成可执行文件，具体一些就是为main编译过程中每一个未定义的符号去编译产物中挨个寻找相应的实现代码，补全符号地址信息。



## C++编译特性
- 编译单元
C/C++的编译系统和其他高级语言存在很大的差异，其他高级语言中，编译单元是整个Module，即Module下所有源码，会在同一个编译任务中执行。而在C/C++中，编译单元是以文件为单位。每个.c/.cc/.cxx/.cpp源文件是一个独立的编译单元，导致编译优化时只能基于本文件内容进行优化，很难跨编译单元提供代码优化。

- 头文件解析
如果N个源文件引用到了同一个头文件，则这个头文件需要解析N次。
如果头文件中有模板，则该模板在每个cpp文件中使用时都会做一次实例化

- 模板函数实例化
>一旦在一个编译单元中使用了外部模板声明，那么编译器在编译时，会跳过与该外部模板声明匹配的模板实例化
显式实例化语法：template class vector
外部模板语法：extern template class vector

## 耗时分析工具
clang-9中增加了一个选项可以产生编译耗时的具体详情，通过它我们可以找到程序真实瓶颈。
通过命令clang++ -ftime-trace -c ./main.cpp -o test 可以在编译的过程中多得到一个.json文件，简单的处理方法是直接拽到chrome://tracing里

## Clang Build Analyzer
对于较为大型的项目来说，往往有成千上万个源文件，相应地在编译过程中也就会生成相当数量的.json文件，显然无法直接分析。此时就可以使用Clang Build Analyzer来汇总所有的json文件对整个工程的构建时间消耗进行分析

## Include What You Use
这是一个用于分析和管理头文件依赖的工具

## 优化与加速手段
#### 并行构建（计算资源充足时）
>- 常规方法：使用-j参数执行make，尽可能地利用计算资源。
>- 再进一步：如果采用标准cmake组织的工程，可以尝试使用ninja替换make进行构建操作，得益于ninja出色的依赖分析再构建时可以得到更好的并行度。相对于用make构建只需要做很少的改变：首先在cmake时用-G指定Ninja，用cmake生成ninja.build（作用类比于makefile），然后ninja -jxxx就可以开始构建了。
>- 代码优化：减少串行依赖和间接依赖。
>- 进阶策略：可以尝试类似于catkin的并行构建思想，除了单个target或者package中代码的并行构建，还可以把各个package的构建并行，可以获得更好的并行程度。但是为了实现模块的并行构建，需要额外维护一份模块间依赖关系的描述文件，例如catkin中的package.xml文件。
>- 用4核的或8核的cpu，每次一build，就是多个文件并行着编
>- 更好的磁盘，编译速度慢很大一部分原因是磁盘操作，除了尽可能的减少磁盘操作，还可以做的就是加快磁盘速度。比如用15000转的磁盘，或者SSD，或者RAID0的
>- 分布式编译（Incredibuild）
利用网络中空闲的cpu资源，以及专门用来编译的build server

#### CCache编译缓存
>- ccache是一个编译缓存工具，其原理是将cpp的编译结果保存在文件缓存中，以后编译时若对应文件无变动可直接从缓存中获取编译结果。需要注意的是，Make本身也有一定缓存功能，当目标文件已编译（且依赖无变化)时，若源文件时间戳无变化也不会再次编译；但CCache是按文件内容做的缓存，且同一机器的多个项目可以共享缓存，因此适用面更大。
>- 使用ccache -s可以查看当前ccache信息，例如剩余缓存空间、命中率等数据。
>- 单机构建：可以通过提高ccache空间来提高命中率。
>- 集群构建：可以尝试使用redis来做ccache存储空间，让构建集群共享编译缓存

#### Unity Build
>Unity Build做法很简单，把所有的cpp包含到一个cpp中(all.cpp) ,然后只编译all.cpp。这样我们就只有一个编译单元，这意味着不需要重复load与解析同一个头文件了，同时因为只产生一个obj文件，在链接的时候也不需要那么密集的磁盘操作了,估计能有10x的提高，看看这个视频感受一下其做法与速度吧。

#### 预编译头文件（​​​​​​​PCH)
>该方法预先将常用头文件的编译结果保存起来，这样编译器在处理对应的头文件引入时可以直接使用预先编译好的结果，从而加快整个编译流程。有的头文件包含了巨量的源代码（如著名的windows.h），或者使用模板编程时要生成巨大的头文件模板库（如Eigen math library与Boost C++ libraries)。为减少编译时间，某些编译器允许把头文件编译为某种中间形式称为预编译头（precompiled header），后续再编译源文件时就可以尽量直接使用这些预编译头。

用CMake启用PHC，确认需要使用PCH特性的头文件，针对头文件所在的target按照如下方式修改cmake
```cpp
target_precompile_headers(myTarget
PUBLIC
  project_header.h
PRIVATE
  [["other_header.h"]]
  <unordered_map>
)
```

对于有特定语言要求的头文件需要手动指定出是C或者C++
```cpp
target_precompile_headers(mylib PRIVATE
 "$<$<COMPILE_LANGUAGE:CXX>:${CMAKE_CURRENT_SOURCE_DIR}/cxx_only.h>"
 "$<$<COMPILE_LANGUAGE:C>:<stddef.h$<ANGLE-R>>"
 "$<$<COMPILE_LANGUAGE:CXX>:<cstddef$<ANGLE-R>>"
)
```

如果有别的模块需要使用之前预编译好的头文件，按如下方式修改cmake
```cpp
target_precompile_headers(<target> REUSE_FROM <other_target>)
```

#### C++20 module
>Module编译是一个优化编译速度的方案，C++20之前的版本会把每一个cpp当做一个编译单元处理，会存在引入的头文件被多次解析编译的问题。而Module的出现就是解决这一问题，Module不再需要头文件（只需要一个模块文件，不需要声明和实现两个文件），它会将你的（.ixx 或者 .cppm）模块实体直接编译，并自动生成一个二进制接口文件。import和include预处理不同，编译好的模块下次import的时候不会重复编译，可以大幅度提高编译器的效率。

- 外部模板
>在执行构建耗时分析后，如果发现编译后端耗时过高可以尝试罗列一下模板实例化的top项
```cpp

```

#### 代码角度
##### 在头文件中使用前置声明，而不是直接包含头文件
>不要以为你只是多加了一个头文件，由于头文件的"被包含"特性，这种效果可能会被无限放大。所以，要尽一切可能使头文件精简。很多时候前置申明某个namespace中的类会比较痛苦，而直接include会方便很多，千万要抵制住这种诱惑；类的成员，函数参数等也尽量用引用，指针，为前置声明创造条件。
##### 使用Pimpl模式
>Pimpl全称为Private Implementation。传统的C++的类的接口与实现是混淆在一起的，而Pimpl这种做法使得类的接口与实现得以完全分离。如此，只要类的公共接口保持不变，对类实现的修改始终只需编译该cpp；同时，该类提供给外界的头文件也会精简许多
##### 高度模块化
>模块化就是低耦合，就是尽可能的减少相互依赖。这里其实有两个层面的意思。一是文件与文件之间，一个头文件的变化，尽量不要引起其他文件的重新编译；二是工程与工程之间，对一个工程的修改，尽量不要引起太多其他工程的编译。这就要求头文件，或者工程的内容一定要单一，不要什么东西都往里面塞，从而引起不必要的依赖。这也可以说是内聚性吧。
以头文件为例，不要把两个不相关的类，或者没什么联系的宏定义放到一个头文件里。内容要尽量单一，从而不会使包含他们的文件包含了不需要的内容。记得我们曾经做过这么一个事，把代码中最"hot"的那些头文件找出来，然后分成多个独立的小文件，效果相当可观。
其实我们去年做过的refactoring，把众多DLL分离成UI与Core两个部分，也是有着相同的效果的 - 提高开发效率。
##### 删除冗余的头文件
>一些代码经过上十年的开发与维护，经手的人无数，很有可能出现包含了没用的头文件，或重复包含的现象，去掉这些冗余的include是相当必要的
##### 特别注意inline和template
>这是C++中两种比较"先进"的机制，但是它们却又强制我们在头文件中包含实现，这对增加头文件的内容，从而减慢编译速度有着很大的贡献。使用之前，权衡一下。
##### 不要有太多的Additional Include Directories
>编译器定位你include的头文件，是根据你提供的include directories进行搜索的。可以想象，如果你提供了100个包含目录，而某个头文件是在第100个目录下，定位它的过程是非常痛苦的。组织好你的包含目录，并尽量保持简洁。


## 参考资料
[如何分析和提高大型项目（C/C++）的编译速度](https://blog.csdn.net/yx5666/article/details/125397429)
[如何加快C++代码的编译速度](https://blog.csdn.net/weixin_34111819/article/details/85443506)
